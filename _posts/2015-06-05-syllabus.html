---
layout: post
featured: images/tools.svg
title: Computers and Screwdrivers
tags: class
---

<p>A programming course to learn how to choose and use the right tools for the job.</p>

<p>Imagine that a carpenter gives you a hammer. They show you how to pound a nail into a board, and then say, “OK, now you’re ready to build houses.” At this point, whoever is hiring you as a contractor is likely to disagree. However, this kind of idea is incredibly pervasive when we talk about learning to code. Between newspaper pieces, presidential speeches and tech CEOs, voices everywhere try to sell the idea that you need to know how to code in order to thrive in the modern world. Undeniably, hammering things is pretty vital for building a house. Undeniably, coding will help you in the modern economy. But if you march around swinging a hammer at everything, you could create more harm than good. Likewise, if you’re really good at hammering together stairs, but your stairs don’t fit into the houses that people are building, those stairs don’t do anyone much good, and could just cause someone to fall later on. A skill is only worthwhile if it can be employed to do something valuable. So we need to learn not only how to hammer, but also when to hammer. </p>


<p>This course will provide a comprehensive introduction to programming which focuses on providing a framework to effectively use a wide array of programming languages and computer-based technologies. The class will cover the essential concepts that form the foundation of many different programming languages and technology stacks. The class aims to provide experience with a variety of application areas, technologies, and languages, while culminating in a final project with a strong focus on good design practices.</p>

<h3>The course will cover the following topics, though not in the order here:</h3>

<ul>
	<li>Programming Paradigms
		<ul>
			<li>Typing (static vs dynamic, strong/weak, etc.)</li>
			<li>Memory allocation and Garbage Collection</li>
			<li>Compilation and interpretation</li>
			<li>Imperitive and Declarative languages</li>
			<li>Structured vs Unstructured Programming</li>
		</ul>
	</li>
	<li>Current Technology Stacks
		<ul>
			<li>Command-line interfaces</li>
			<li>Native applications and GUI frameworks</li>
			<li>HTML + CSS</li>
			<li>Server-side and client-side languages (the internets)</li>
		</ul>
	</li>
	<li>Design Practices
		<ul>
			<li>Commenting and Documentation</li>
			<li>Version Control</li>
			<li>Object-oriented programming</li>
		</ul>
	</li>
</ul>
