<html>
  <head>
    <link rel="stylesheet" type="text/css" href="styles/reset.css" />
    <link rel="stylesheet" type="text/css" href="styles/style.css" />
    <link rel="stylesheet" type="text/css" href="styles/columnLayout.css" />
    <link
      href="https://fonts.googleapis.com/css?family=Abel|Shrikhand"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://use.fontawesome.com/releases/v5.1.0/css/all.css"
      integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt"
      crossorigin="anonymous"
    />


    <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>

  <body>
    <div class="container">
      <h1>Jimmy McNulty</h1>
      <p>
        Traveler From the Forest Dimension
      </p>
    </div>
    <img style="width:100vw" src="/assets/gravity_sketch_collage.png" />

    <script type="x-shader/x-vertex" id="vertexShader">

			attribute vec3 center;
			varying vec3 vCenter;
			varying vec3 vNorm;

			void main() {

				vCenter = center;
        vNorm = normal;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>
    <script type="x-shader/x-fragment" id="fragmentShader">

			uniform float thickness;

			varying vec3 vCenter;
			varying vec3 vNorm;

			void main() {

				vec3 afwidth = fwidth( vCenter.xyz );

				vec3 edge3 = smoothstep( ( thickness - 1.0 ) * afwidth, thickness * afwidth, vCenter.xyz );

				float edge = 1.0 - min( min( edge3.x, edge3.y ), edge3.z );

        gl_FragColor.rgb = vNorm.xyz;

								gl_FragColor.a = edge;

			}

		</script>
<!-- gl_FragColor.rgb = gl_FrontFacing
          ? vec3( 0.2, 0.9, 1.0 )
          : vec3( 0.4, 0.4, 0.5 );
 -->

    <div>
      <h1>Buildings go through different looks too.</h1>
      <div class="pane">
        <img src="assets/Buildings/b1.JPG" />
        <img src="assets/Buildings/b2.JPG" />
        <img src="assets/Buildings/b3.JPG" />
        <img src="assets/Buildings/b4.JPG" />
      </div>
    </div>

    <model-viewer
      style="width:75vw; height:75vh"
      src="/assets/robot2.glb"
      ar ar-modes="webxr scene-viewer quick-look"
      shadow-intensity="1"
      camera-orbit="-61.42deg 100.3deg 3.844m"
      field-of-view="35.58deg"
      >
    </model-viewer>
    <img id="letters" src="/assets/ConsolasLetters.jpg" />
    <canvas></canvas>
    <script src="/vendor/three.js"></script>
    <script>
      function createScene() {
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(
          -2, 2, 1, -1,
          0.01,
          1000
        );
        camera.position.set(5, 5, 5);
        camera.lookAt(0, 0, 0);


        const canvas = document.querySelector('canvas');
        const renderer = new THREE.WebGLRenderer({canvas});
        renderer.setSize(
          window.innerWidth,
          window.innerHeight
        );
        document.body.appendChild(
          renderer.domElement
        );
        return { scene, camera, renderer, canvas };
      }
      function getLetterPlane(letterIndex) {
        const geometry = new THREE.PlaneGeometry();
        // const tex = new THREE.Texture(document.getElementById('letters'));
        // const material = new THREE.SpriteMaterial({
        //   map: tex
        // });
        const loader = new THREE.TextureLoader();
        const texture = loader.load(
          '/assets/ConsolasLetters.jpg',
        );


        const row = Math.floor((26-letterIndex) / 7);
        const col = letterIndex % 7;
        console.log(row, col);
        texture.offset = new THREE.Vector2(
          col * .11,
          row * .25
        );
        texture.repeat = new THREE.Vector2(.14,.18);
        const material = new THREE.MeshBasicMaterial({
          map: texture
        });
        const plane = new THREE.Mesh(geometry, material);
        return {plane, geometry, material};
      }


      function getCube() {
        const geometry = new THREE.BoxGeometry( 1, 1, 1 );

        const material = new THREE.ShaderMaterial( {
          uniforms: { 'thickness': { value: 2} },
          vertexShader: document.getElementById( 'vertexShader' ).textContent,
          fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
          side: THREE.DoubleSide,
          alphaToCoverage: true // only works when WebGLRenderer's "antialias" is set to "true"
        } );
        material.extensions.derivatives = true;
        const cube = new THREE.Mesh( geometry, material );
        return {cube, geometry, material };
      }

      const scene = createScene();
      // const cube = getCube();
      // scene.scene.add( cube.cube );

      const plane = getLetterPlane(6);
      scene.scene.add(plane.plane);

      let targetRot = 0;
      const lerpAmt = .9;

      scene.canvas.addEventListener("click", (event) => {
        targetRot += Math.PI /2;
      });


      function animate(scene) {
        window.requestAnimationFrame( () => animate(scene) );
        scene.renderer.render( scene.scene, scene.camera );
     //   cube.cube.rotation.y = lerpAmt * cube.cube.rotation.y + (1-lerpAmt) * targetRot;
      }
      animate(scene);
    </script>
  </body>
</html>
